$date
  Sat Oct 31 11:36:52 2020
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module adder_4_bit_tb $end
$var reg 4 ! a[3:0] $end
$var reg 4 " b[3:0] $end
$var reg 1 # cin $end
$var reg 4 $ sum[3:0] $end
$var reg 1 % cout $end
$scope module adder_4_bit_instance $end
$var reg 4 & a[3:0] $end
$var reg 4 ' b[3:0] $end
$var reg 1 ( cin $end
$var reg 4 ) sum[3:0] $end
$var reg 1 * cout $end
$var reg 3 + c_temp[2:0] $end
$scope module bit0 $end
$var reg 1 , a $end
$var reg 1 - b $end
$var reg 1 . cin $end
$var reg 1 / sum $end
$var reg 1 0 cout $end
$upscope $end
$scope module bit1 $end
$var reg 1 1 a $end
$var reg 1 2 b $end
$var reg 1 3 cin $end
$var reg 1 4 sum $end
$var reg 1 5 cout $end
$upscope $end
$scope module bit2 $end
$var reg 1 6 a $end
$var reg 1 7 b $end
$var reg 1 8 cin $end
$var reg 1 9 sum $end
$var reg 1 : cout $end
$upscope $end
$scope module bit3 $end
$var reg 1 ; a $end
$var reg 1 < b $end
$var reg 1 = cin $end
$var reg 1 > sum $end
$var reg 1 ? cout $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
b1100 !
b0101 "
0#
b0001 $
1%
b1100 &
b0101 '
0(
b0001 )
1*
b100 +
0,
1-
0.
1/
00
01
02
03
04
05
16
17
08
09
1:
1;
0<
1=
0>
1?
#50000000
b1110 !
b0011 "
b0001 $
1%
b1110 &
b0011 '
b0001 )
1*
b110 +
11
12
15
07
18
09
1:
1=
0>
1?
#100000000
b1001 !
b1101 "
1#
b0111 $
b1001 &
b1101 '
1(
b0111 )
b001 +
1,
1.
10
01
02
13
14
05
06
17
08
19
0:
1<
0=
0>
#150000000
b1100 !
b0101 "
0#
b0001 $
1%
b1100 &
b0101 '
0(
b0001 )
1*
b100 +
0,
0.
00
03
04
16
09
1:
0<
1=
0>
1?
